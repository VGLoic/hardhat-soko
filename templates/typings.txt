// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.
import fs from "fs/promises";
import { PROJECTS, SOKO_PATH } from "./summary-exports";
type AccurateProject = keyof typeof PROJECTS;
export type Project = AccurateProject extends never ? string : AccurateProject;

export type Contract<TProject> = TProject extends AccurateProject
  ? keyof (typeof PROJECTS)[TProject]["contracts"]
  : string;
export type Tag<TProject> = TProject extends AccurateProject
  ? keyof (typeof PROJECTS)[TProject]["tags"]
  : string;

type AvailableTagForContractAsArray<TProject, TContract> =
  TProject extends AccurateProject
    ? TContract extends Contract<TProject>
      ? (typeof PROJECTS)[TProject]["contracts"][TContract]
      : string[]
    : string[];

export type AvailableTagForContract<TProject, TContract> =
  AvailableTagForContractAsArray<TProject, TContract>[number];

type AvailableContractsForTagAsArray<TProject, TTag> =
  TProject extends AccurateProject
    ? TTag extends Tag<TProject>
      ? (typeof PROJECTS)[TProject]["tags"][TTag]
      : string[]
    : string[];
export type AvailableContractForTag<TProject, TTag> =
  AvailableContractsForTagAsArray<TProject, TTag>[number];

export function project<TProject extends Project>(project: TProject) {
  return {
    /**
     * Get the available tags for the project
     * @returns The array of available tags
     */
    getAvailableTags(): Tag<TProject>[] {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return Object.keys((PROJECTS as any)[project].tags) as Tag<TProject>[];
    },
    /**
     * Get the available contracts for the project
     * @returns The array of available contracts. Each contract is formatted as "path/to/Contract.sol:Contract"
     */
    getAvailableContracts(): Contract<TProject>[] {
      return Object.keys(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (PROJECTS as any)[project].contracts,
      ) as Contract<TProject>[];
    },
    /**
     * Utility functions for a given contract
     * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
     * @returns Utility functions for the given contract
     * @example ```typescript
     * const counterUtils = project("my-project").contract("src/Counter.sol:Counter");
     * const availableTags = counterUtils.getAvailableTags();
     * const counterArtifact = await counterUtils.getArtifact("v1.3.1");
     * ```
     */
    contract<TContract extends Contract<TProject>>(contractKey: TContract) {
      return {
        getArtifact(tag: AvailableTagForContract<TProject, TContract>) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getAvailableTags(): AvailableTagForContractAsArray<
          TProject,
          TContract
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].contracts[contractKey as string];
        },
      };
    },
    /**
     * Utility functions for a given tag
     * @param tag Tag
     * @returns Utility functions for the given tag
     * @example ```typescript
     * const v1_3_1Utils = project("my-project").tag("v1.3.1");
     * const availableContracts = v1_3_1Utils.getAvailableContracts();
     * const compilationArtifact = await v1_3_1Utils.getCompilationArtifact();
     * const incrementOracleArtifact = await v1_3_1Utils.getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
     * ```
     */
    tag<TTag extends Tag<TProject>>(tag: TTag) {
      return {
        getContractArtifact(
          contractKey: AvailableContractForTag<TProject, TTag>,
        ) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getAvailableContracts(): AvailableContractsForTagAsArray<
          TProject,
          TTag
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].tags[tag];
        },
        getCompilationArtifact() {
          return getCompilationArtifact(project, tag as string);
        },
      };
    },
  };
}

async function getArtifact(
  project: string,
  tag: string,
  contractKey: string,
): Promise<CompilerOutputContract> {
  const buildInfoResult = await toAsyncResult(
    getCompilationArtifact(project, tag),
  );
  if (!buildInfoResult.success) {
    throw buildInfoResult.error;
  }

  const contractPieces = contractKey.split(":");
  const contractName = contractPieces.at(-1);
  if (!contractName) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const contractPath = contractPieces.at(0);
  if (!contractPath) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const contractArtifact =
    buildInfoResult.value.output.contracts[contractPath][contractName];
  if (!contractArtifact) {
    throw new Error(
      `Contract artifact not found for contract key: ${contractKey} with artifact ${project}:${tag}`,
    );
  }
  return contractArtifact;
}

/**
 * Get a compilation artifact
 * @param project Related project
 * @param tag Tag of the compilation
 * @returns The compilation artifact
 */
async function getCompilationArtifact(
  project: string,
  tag: string,
): Promise<BuildInfo> {
  const buildInfoExists = await fs
    .stat(`${SOKO_PATH}/${project}/tags/${tag}.json`)
    .catch(() => false);
  if (!buildInfoExists) {
    throw new Error(`artifact not found for "${project}:${tag}". Skipping`);
  }
  const buildInfoContentResult = await toAsyncResult(
    fs
      .readFile(`${SOKO_PATH}/${project}/tags/${tag}.json`, "utf-8")
      .then(JSON.parse),
  );
  if (!buildInfoContentResult.success) {
    console.error(buildInfoContentResult.error);
    throw buildInfoContentResult.error;
  }

  return buildInfoContentResult.value;
}

function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}

/**
 * @dev These types are imported from hardhat/types
 * They are extended with our knowledge of the types
 */
interface BuildInfo {
  id: string;
  solcVersion: string;
  solcLongVersion: string;
  _format?: string;
  input: CompilerInput;
  output: CompilerOutput;
}

interface CompilerInput {
  language: string;
  sources: { [sourceName: string]: { content: string } };
  settings: {
    viaIR?: boolean;
    optimizer: {
      runs?: number;
      enabled?: boolean;
      details?: {
        yulDetails: {
          optimizerSteps: string;
        };
      };
    };
    metadata?: { useLiteralContent: boolean };
    outputSelection: {
      [sourceName: string]: {
        [contractName: string]: string[];
      };
    };
    evmVersion?: string;
    libraries?: {
      [libraryFileName: string]: {
        [libraryName: string]: string;
      };
    };
    remappings?: string[];
  };
}

interface CompilerOutput {
  sources: CompilerOutputSources;
  contracts: {
    [sourceName: string]: {
      [contractName: string]: CompilerOutputContract;
    };
  };
}

interface CompilerOutputSources {
  [sourceName: string]: CompilerOutputSource;
}

interface CompilerOutputSource {
  id: number;
  ast: unknown;
}

interface CompilerOutputContract {
  abi: unknown[];
  metadata?: string;
  userdoc?: unknown;
  devdoc?: unknown;
  ir?: string;
  irAst?: unknown;
  irOptimized?: string;
  irOptimizedAst?: unknown;
  storageLayout?: {
    storage: unknown[];
    types: unknown;
  };
  transientStorageLayout?: unknown;
  evm: {
    assembly?: string;
    bytecode: CompilerOutputBytecode;
    deployedBytecode?: CompilerOutputBytecode;
    gasEstimates?: {
      creation?: Record<string, string>;
      external?: Record<string, string>;
      internal?: Record<string, string>;
    };
    methodIdentifiers?: {
      [methodSignature: string]: string;
    };
  };
}

interface CompilerOutputBytecode {
  functionDebugData?: Record<string, unknown>;
  object: string;
  opcodes: string;
  sourceMap?: string;
  generatedSources: unknown[];
  linkReferences: LinkReferences;
  immutableReferences?: {
    [key: string]: Array<{ start: number; length: number }>;
  };
}

interface LinkReferences {
  [libraryFileName: string]: {
    [libraryName: string]: Array<{ length: number; start: number }>;
  };
}
