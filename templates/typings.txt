// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.
import fs from "fs/promises";
import { CONTRACTS, RELEASES, SOKO_DIRECTORY } from "./summary";

export type Contract = keyof typeof CONTRACTS;
export type Release = keyof typeof RELEASES;

export type AvailableReleaseForContract<TContract extends Contract> =
  (typeof CONTRACTS)[TContract][number];

export type AvailableContractForRelease<TRelease extends Release> =
  (typeof RELEASES)[TRelease][number];
  
// eslint-disable-next-line @typescript-eslint/ban-types
type FallbackString = string & {};
/**
 * Utility functions for a given contract
 * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
 * @returns Utility functions for the given contract
 * @example ```typescript
 * const counterUtils = contract("src/Counter.sol:Counter");
 * const availableReleases = counterUtils.getAvailableReleases();
 * const counterArtifact = await counterUtils.getArtifact("v1.3.1");
 * ```
 */
export function contract<TContract extends Contract | FallbackString>(
  contractKey: TContract,
) {
  return {
    /**
     * Retrieve the contract artifact for a given release
     * @param release Release name
     * @returns The contract artifact
     * @example ```typescript
     * const counterArtifact = await contract("src/Counter.sol:Counter").getArtifact("v1.3.1");
     * ```
     */
    getArtifact(
      release: Contract extends never
        ? string
        : TContract extends Contract
        ? AvailableReleaseForContract<TContract>
        : never,
    ) {
      return getArtifact(contractKey, release);
    },
    /**
     * Get the available releases for the contract
     * @returns The available releases for the contract
     */
    getAvailableReleases: (): TContract extends Contract
      ? (typeof CONTRACTS)[TContract]
      : string[] => {
      if (contractKey in CONTRACTS) {
        return CONTRACTS[
          contractKey as Contract
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ] as any;
      }
      throw new Error(`Contract not found for contract key: ${contractKey}`);
    },
  };
}

/**
 * Utility functions for a given release
 * @param release Release name
 * @returns Utility functions for the given release
 * @example ```typescript
 * const v1_3_1Utils = release("v1.3.1");
 * const availableContracts = v1_3_1Utils.getAvailableContracts();
 * const incrementOracleArtifact = await v1_3_1Utils.getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
 * ```
 */
export function release<TRelease extends Release | FallbackString>(
  release: TRelease,
) {
  return {
    /**
     * Retrieve the contract artifact for a given contract
     * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
     * @returns The contract artifact
     * @example ```typescript
     * const incrementOracleArtifact = await release("v1.3.1").getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
     * ```
     */
    getContractArtifact(
      contractKey: TRelease extends Release
        ? AvailableContractForRelease<TRelease>
        : string,
    ) {
      return getArtifact(contractKey, release);
    },
    /**
     * Get the available contracts for the release
     * @returns The available contracts for the release
     */
    getAvailableContracts: (): TRelease extends Release
      ? (typeof RELEASES)[TRelease]
      : string[] => {
      if (release in RELEASES) {
        return RELEASES[
          release as Release
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ] as any;
      }
      throw new Error(`Release not found for release: ${release}`);
    },
  };
}

async function getArtifact(
  contractKey: string,
  release: string,
): Promise<unknown> {
  const buildInfoResult = await toAsyncResult(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getReleaseBuildInfo(release as any),
  );
  if (!buildInfoResult.success) {
    throw buildInfoResult.error;
  }

  const contractPieces = contractKey.split(":");
  const contractName = contractPieces.at(-1);
  if (!contractName) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const contractPath = contractPieces.at(0);
  if (!contractPath) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const contractArtifact = (buildInfoResult.value as any).output.contracts[
    contractPath
  ][contractName];
  if (!contractArtifact) {
    throw new Error(
      `Contract artifact not found for contract key: ${contractKey} with release ${release}`,
    );
  }
  return contractArtifact;
}

/**
 * Get the artifact of a release
 * @param release Name of the release
 * @returns The build info content of the release
 * @example ```typescript
 * const releaseBuildInfo = await getReleaseBuildInfo("v1.3.1");
 * ```
 */
export async function getReleaseBuildInfo(
  release: Release extends never ? string : Release,
): Promise<unknown> {
  const buildInfoExists = await fs
    .stat(`${SOKO_DIRECTORY}/${release}/build-info.json`)
    .catch(() => false);
  if (!buildInfoExists) {
    throw new Error(
      `build-info.json not found for release ${release}. Skipping`,
    );
  }
  const buildInfoContentResult = await toAsyncResult(
    fs
      .readFile(`${SOKO_DIRECTORY}/${release}/build-info.json`, "utf-8")
      .then(JSON.parse),
  );
  if (!buildInfoContentResult.success) {
    console.error(buildInfoContentResult.error);
    throw buildInfoContentResult.error;
  }

  return buildInfoContentResult.value;
}

function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}
