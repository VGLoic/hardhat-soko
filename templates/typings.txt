// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.
import fs from "fs/promises";
import { PROJECTS, SOKO_PATH } from "./summary-exports";

type AccurateProject = keyof typeof PROJECTS;
export type Project = AccurateProject extends never ? string : AccurateProject;

export type Contract<TProject> = TProject extends AccurateProject
  ? keyof (typeof PROJECTS)[TProject]["contracts"]
  : string;
export type Tag<TProject> = TProject extends AccurateProject
  ? keyof (typeof PROJECTS)[TProject]["tags"]
  : string;

type AvailableTagForContractAsArray<TProject, TContract> =
  TProject extends AccurateProject
    ? TContract extends Contract<TProject>
      ? (typeof PROJECTS)[TProject]["contracts"][TContract]
      : string[]
    : string[];

export type AvailableTagForContract<TProject, TContract> =
  AvailableTagForContractAsArray<TProject, TContract>[number];

type AvailableContractsForTagAsArray<TProject, TTag> =
  TProject extends AccurateProject
    ? TTag extends Tag<TProject>
      ? (typeof PROJECTS)[TProject]["tags"][TTag]
      : string[]
    : string[];
export type AvailableContractForTag<TProject, TTag> =
  AvailableContractsForTagAsArray<TProject, TTag>[number];

export function project<TProject extends Project>(project: TProject) {
  return {
    /**
     * Get the available tags for the project
     * @returns The array of available tags
     */
    getAvailableTags(): Tag<TProject>[] {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return (PROJECTS as any)[project].tags;
    },
    /**
     * Get the available contracts for the project
     * @returns The array of available contracts. Each contract is formatted as "path/to/Contract.sol:Contract"
     */
    getAvailableContracts(): Contract<TProject>[] {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return (PROJECTS as any)[project].contracts;
    },
    /**
     * Utility functions for a given contract
     * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
     * @returns Utility functions for the given contract
     * @example ```typescript
     * const counterUtils = project("my-project").contract("src/Counter.sol:Counter");
     * const availableTags = counterUtils.getAvailableTags();
     * const counterArtifact = await counterUtils.getArtifact("v1.3.1");
     * ```
     */
    contract<TContract extends Contract<TProject>>(contractKey: TContract) {
      return {
        getArtifact(tag: AvailableTagForContract<TProject, TContract>) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getAvailableTags(): AvailableTagForContractAsArray<
          TProject,
          TContract
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].contracts[contractKey as string];
        },
      };
    },
    /**
     * Utility functions for a given tag
     * @param tag Tag
     * @returns Utility functions for the given tag
     * @example ```typescript
     * const v1_3_1Utils = project("my-project").tag("v1.3.1");
     * const availableContracts = v1_3_1Utils.getAvailableContracts();
     * const compilationArtifact = await v1_3_1Utils.getCompilationArtifact();
     * const incrementOracleArtifact = await v1_3_1Utils.getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
     * ```
     */
    tag<TTag extends Tag<TProject>>(tag: TTag) {
      return {
        getContractArtifact(
          contractKey: AvailableContractForTag<TProject, TTag>,
        ) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getAvailableContracts(): AvailableContractsForTagAsArray<
          TProject,
          TTag
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].tags[tag];
        },
        getCompilationArtifact() {
          return getCompilationArtifact(project, tag as string);
        },
      };
    },
  };
}

async function getArtifact(
  project: string,
  tag: string,
  contractKey: string,
): Promise<unknown> {
  const buildInfoResult = await toAsyncResult(
    getCompilationArtifact(project, tag),
  );
  if (!buildInfoResult.success) {
    throw buildInfoResult.error;
  }

  const contractPieces = contractKey.split(":");
  const contractName = contractPieces.at(-1);
  if (!contractName) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const contractPath = contractPieces.at(0);
  if (!contractPath) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const contractArtifact = (buildInfoResult.value as any).output.contracts[
    contractPath
  ][contractName];
  if (!contractArtifact) {
    throw new Error(
      `Contract artifact not found for contract key: ${contractKey} with artifact ${project}:${tag}`,
    );
  }
  return contractArtifact;
}

/**
 * Get a compilation artifact
 * @param project Related project
 * @param tag Tag of the compilation
 * @returns The compilation artifact
 */
async function getCompilationArtifact(
  project: string,
  tag: string,
): Promise<unknown> {
  const buildInfoExists = await fs
    .stat(`${SOKO_PATH}/${project}/tags/${tag}.json`)
    .catch(() => false);
  if (!buildInfoExists) {
    throw new Error(`artifact not found for "${project}:${tag}". Skipping`);
  }
  const buildInfoContentResult = await toAsyncResult(
    fs
      .readFile(`${SOKO_PATH}/${project}/tags/${tag}.json`, "utf-8")
      .then(JSON.parse),
  );
  if (!buildInfoContentResult.success) {
    console.error(buildInfoContentResult.error);
    throw buildInfoContentResult.error;
  }

  return buildInfoContentResult.value;
}

function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}
