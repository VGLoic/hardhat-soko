import { Dirent } from "fs";
import fs from "fs/promises";
import { z } from "zod";
import { keccak256 } from "@ethersproject/keccak256";
import { toUtf8Bytes } from "@ethersproject/strings";

export function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}

export class ScriptError extends Error {
  constructor(message: string) {
    super(message);
  }
}

export const LOG_COLORS = {
  log: "\x1b[0m%s\x1b[0m",
  success: "\x1b[32m%s\x1b[0m",
  error: "\x1b[31m%s\x1b[0m",
  warn: "\x1b[33m%s\x1b[0m",
};

const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
type Literal = z.infer<typeof literalSchema>;
type Json = Literal | { [key: string]: Json } | Json[];
const ZJson: z.ZodType<Json> = z.lazy(() =>
  z.union([literalSchema, z.array(ZJson), z.record(ZJson)]),
);

const ZBytecode = z.object({
  // Debugging data at the level of functions.
  functionDebugData: z.record(z.string(), ZJson).optional(),
  // The bytecode as a hex string.
  object: z.string(),
  // Opcodes list (string)
  opcodes: z.string().optional(),
  // The source mapping as a string. See the source mapping definition.
  sourceMap: z.string().optional(),
  // Array of sources generated by the compiler. Currently only contains a single Yul file.
  generatedSources: z.array(ZJson).optional(),
  // If given, this is an unlinked object.
  linkReferences: z
    .record(
      z.record(
        z.string(),
        z.array(
          z.object({
            length: z.number(),
            start: z.number(),
          }),
        ),
      ),
    )
    .optional(),
});

const ZAbi = z.array(
  z.object({
    inputs: z.array(ZJson),
    name: z.string(),
    outputs: z.array(ZJson).optional(),
    stateMutability: z.string(),
    type: z.string(),
  }),
);

const ZCompilerOutputContract = z.object({
  // The Ethereum Contract ABI. If empty, it is represented as an empty array.
  // See https://docs.soliditylang.org/en/develop/abi-spec.html
  abi: ZAbi,
  // See the Metadata Output documentation (serialised JSON string)
  metadata: z.string(),
  // User documentation (natspec)
  userdoc: ZJson.optional(),
  // Developer documentation (natspec)
  devdoc: ZJson.optional(),
  // Intermediate representation before optimization (string)
  ir: z.string().optional(),
  // AST of intermediate representation before optimization
  irAst: ZJson.optional(),
  // Intermediate representation after optimization (string)
  irOptimized: z.string().optional(),
  // AST of intermediate representation after optimization
  irOptimizedAst: ZJson.optional(),
  // See the Storage Layout documentation.
  storageLayout: z
    .object({
      storage: z.array(ZJson),
      types: ZJson,
    })
    .optional(),
  // See the Storage Layout documentation.
  transientStorageLayout: ZJson.optional(),
  // EVM-related outputs
  evm: z.object({
    // Assembly (string)
    assembly: z.string().optional(),
    // Bytecode and related details
    bytecode: ZBytecode,
    deployedBytecode: ZBytecode.extend({
      immutableReferences: ZJson.optional(),
    }).optional(),
    // Function gas estimates
    gasEstimates: z
      .object({
        creation: z.record(z.string(), z.string()).optional(),
        external: z.record(z.string(), z.string()).optional(),
        internal: z.record(z.string(), z.string()).optional(),
      })
      .optional(),
    // The list of function hashes
    methodIdentifiers: z.record(z.string(), z.string()).optional(),
  }),
});
export type CompilerOutputContract = z.infer<typeof ZCompilerOutputContract>;
const ZSettings = z.object({
  viaIR: z.boolean().optional(),
  optimizer: z.object({
    runs: z.number().optional(),
    enabled: z.boolean().optional(),
    details: z
      .object({
        yulDetails: z.object({
          optimizerSteps: z.string(),
        }),
      })
      .optional(),
  }),
  metadata: z
    .object({
      useLiteralContent: z.boolean().optional(),
      bytecodeHash: z.string().optional(),
    })
    .optional(),
  outputSelection: z
    .record(z.string(), z.record(z.string(), z.array(z.string())))
    .optional(),
  compilationTarget: z.record(z.string(), z.string()).optional(),
  evmVersion: z.string().optional(),
  libraries: z.record(z.string(), z.record(z.string(), z.string())).optional(),
  remappings: z.array(z.string()).optional(),
});
export const ZBuildInfo = z.object({
  id: z.string(),
  solcVersion: z.string().optional(),
  solcLongVersion: z.string(),
  _format: z.string().optional(),
  input: z.object({
    language: z.string(),
    sources: z.record(z.string(), ZJson),
    settings: ZSettings,
  }),
  output: z.object({
    contracts: z.record(
      z.string(),
      z.record(z.string(), ZCompilerOutputContract),
    ),
    sources: z
      .record(z.string(), z.object({ id: z.number(), ast: ZJson }))
      .optional(),
  }),
});

export async function retrieveFreshCompilationArtifact(
  inputPath: string,
): Promise<
  | {
      status: "success";
      path: string;
      content: string;
    }
  | {
      status: "error";
      reason: string;
    }
> {
  const stat = await fs.stat(inputPath).catch(() => undefined);
  if (!stat) {
    return {
      status: "error",
      reason: `Input path "${inputPath}" not found`,
    };
  }

  let compilationArtifactPath: string | undefined = undefined;

  if (stat.isFile()) {
    if (!inputPath.endsWith(".json")) {
      return {
        status: "error",
        reason: `The file at path "${inputPath}" is not a json file. Compilation artifact must be a json file.`,
      };
    }
    compilationArtifactPath = inputPath;
  } else if (stat.isDirectory()) {
    const entries = await fs.readdir(inputPath, { withFileTypes: true });

    let finalCompilationArtifactsDirectoryEntries: Dirent[] | undefined =
      undefined;
    let finalBasePath: string = inputPath;

    // If we found only json files, we assume that we are in the final folder, we then expect only one file
    if (
      entries.every((entry) => entry.isFile() && entry.name.endsWith(".json"))
    ) {
      console.error(
        LOG_COLORS.log,
        `Found potential compilation artifacts in path "${inputPath}"`,
      );
      finalCompilationArtifactsDirectoryEntries = entries;
    }

    // If we found a build-info folder, we can dig into it
    const buildInfoFolderEntry = entries.find(
      (entry) => entry.isDirectory() && entry.name === "build-info",
    );
    if (buildInfoFolderEntry) {
      finalBasePath = `${inputPath}/${buildInfoFolderEntry.name}`;
      finalCompilationArtifactsDirectoryEntries = await fs.readdir(
        `${inputPath}/${buildInfoFolderEntry.name}`,
        { withFileTypes: true },
      );
    }

    if (!finalCompilationArtifactsDirectoryEntries) {
      return {
        status: "error",
        reason: `Failed to find compilation artifacts in path "${inputPath}". Please provide a more precise path.`,
      };
    }

    const checkResult = checkCompilationArtifactsFolder(
      finalCompilationArtifactsDirectoryEntries,
    );
    if (checkResult.status === "error") {
      return checkResult;
    }

    compilationArtifactPath = `${finalBasePath}/${checkResult.name}`;
    console.error(
      LOG_COLORS.log,
      `Found a potential compilation artifact in path "${compilationArtifactPath}"`,
    );
  } else {
    return {
      status: "error",
      reason: `Thing at path "${inputPath}" is neither identified as a file nor as a directory. This thing is not yet supported`,
    };
  }

  if (!compilationArtifactPath) {
    throw new Error("No compilation artifact found");
  }

  const contentResult = await toAsyncResult(
    readBuildInfoFile(compilationArtifactPath),
  );

  if (!contentResult.success) {
    throw new Error(`Error reading build info file: ${contentResult.error}`);
  }

  return {
    status: "success",
    path: compilationArtifactPath,
    content: contentResult.value,
  };
}

const ZForgeBuildInfo = z.object({
  language: z.string(),
  id: z.string(),
  source_id_to_path: z.record(z.string(), z.string()),
});

async function readBuildInfoFile(path: string): Promise<string> {
  const readResult = await toAsyncResult(fs.readFile(path, "utf-8"));
  if (!readResult.success) {
    throw new Error(`Error reading build info file: ${readResult.error}`);
  }
  const rawParsing = JSON.parse(readResult.value);
  const finalParsingResult = ZBuildInfo.safeParse(rawParsing);
  if (finalParsingResult.success) {
    // We have a valid build info file, probably Hardhat style, we can return it
    return readResult.value;
  }

  // If we don't have a valid build info file, we try to identify it as a Forge style build info file
  const forgeParsingResult = ZForgeBuildInfo.safeParse(rawParsing);
  if (forgeParsingResult.success) {
    // We can now rebuild the build info file using this
    return rebuildBuildInfoFromForgeFormat(path, forgeParsingResult.data);
  }

  throw new Error(
    `The build info file at path "${path}" has an unknown format. For now only Hardhat and Forge are supported.`,
  );
}

const ZForgeContractCompilationOutput = z.object({
  // Map to output.contracts.<contract>.abi
  abi: ZAbi,
  // Map to output.contracts.<contract>.evm.bytecode
  bytecode: ZBytecode,
  // Map to output.contracts.<contract>.evm.deployedBytecode
  deployedBytecode: ZBytecode.optional(),
  // Map to output.contracts.<contract>.evm.methodIdentifiers
  methodIdentifiers: z.record(z.string(), z.string()).optional(),
  // Map to output.contracts.<contract>.metadata
  rawMetadata: z.string(),
  metadata: z.object({
    compiler: z.object({
      // Map to solcLongVersion
      version: z.string(),
    }),
    // Map to input.language
    language: z.string(),
    output: z.object({
      abi: ZAbi,
      // Map to output.contracts.<contract>.devdoc
      devdoc: ZJson.optional(),
      // Map to output.contracts.<contract>.userdoc
      userdoc: ZJson.optional(),
    }),
    // Map to input.settings
    settings: ZSettings.extend({
      compilationTarget: z.record(z.string(), z.string()),
    }),
    // Map to input.sources
    sources: z.record(z.string(), ZJson),
    version: z.number(),
  }),
});

async function rebuildBuildInfoFromForgeFormat(
  buildInfoPath: string,
  forgeBuildInfo: z.infer<typeof ZForgeBuildInfo>,
): Promise<string> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const buildInfo: Record<string, any> = {};

  const pathElements = buildInfoPath.split("/");
  pathElements.pop();
  pathElements.push("..");
  const basePath = pathElements.join("/");

  const expectedPaths = Object.values(forgeBuildInfo.source_id_to_path);
  const expectedPathsSet = new Set(expectedPaths);

  if (expectedPaths.length === 0) {
    throw new Error("Empty build info file");
  }

  for await (const artifactPath of lookForContractArtifactPath(basePath)) {
    const contractContentResult = await toAsyncResult(
      fs.readFile(artifactPath, "utf-8").then((content) => {
        const rawParsing = JSON.parse(content);
        return ZForgeContractCompilationOutput.parse(rawParsing);
      }),
    );
    if (!contractContentResult.success) {
      throw new Error(
        `Error reading contract file "${artifactPath}": ${contractContentResult.error}`,
      );
    }

    // For the first contract, we can fill the common fields
    if (!buildInfo.id) {
      const keptSettings: Record<string, unknown> = {
        ...contractContentResult.value.metadata.settings,
      };
      delete keptSettings.compilationTarget;

      buildInfo["id"] = forgeBuildInfo.id;
      buildInfo["solcLongVersion"] =
        contractContentResult.value.metadata.compiler.version;
      buildInfo["input"] = {
        language: contractContentResult.value.metadata.language,
        sources: contractContentResult.value.metadata.sources,
        settings: keptSettings,
      };
      buildInfo["output"] = {
        contracts: {},
        sources: {},
      };
    }

    const compilationTargetEntries = Object.entries(
      contractContentResult.value.metadata.settings.compilationTarget,
    );
    if (compilationTargetEntries.length !== 1) {
      throw new Error(
        `Invalid compilation target in contract file "${artifactPath}"`,
      );
    }
    const [contractPath, contractName] = compilationTargetEntries[0];
    if (!expectedPathsSet.has(contractPath)) {
      throw new Error(
        `Invalid compilation target in contract file "${contractPath}"`,
      );
    }

    if (!buildInfo.output.contracts[contractPath]) {
      buildInfo.output.contracts[contractPath] = {};
    }

    buildInfo.output.contracts[contractPath][contractName] = {
      abi: contractContentResult.value.abi,
      metadata: contractContentResult.value.rawMetadata,
      userdoc: contractContentResult.value.metadata.output.userdoc,
      devdoc: contractContentResult.value.metadata.output.devdoc,
      evm: {
        bytecode: contractContentResult.value.bytecode,
        deployedBytecode: contractContentResult.value.deployedBytecode,
        methodIdentifiers: contractContentResult.value.methodIdentifiers,
      },
    };

    const contractSourceCode = await fs
      .readFile(contractPath, "utf-8")
      .catch(() => undefined);
    if (contractSourceCode) {
      const hash = keccak256(toUtf8Bytes(contractSourceCode));
      if (
        hash ===
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (contractContentResult.value?.metadata?.sources[contractPath] as any)
          ?.keccak256
      ) {
        buildInfo.input.sources[contractPath]["content"] = contractSourceCode;
      }
    }
  }

  return JSON.stringify(buildInfo);
}

function checkCompilationArtifactsFolder(entries: Dirent[]):
  | {
      status: "success";
      name: string;
    }
  | { status: "error"; reason: string } {
  if (entries.length > 1) {
    return {
      status: "error",
      reason: `Found multiple potential compilation artifacts in the Hardhat build info folders. Please provide a more precise path.`,
    };
  } else {
    return {
      status: "success",
      name: entries[0].name,
    };
  }
}

async function* lookForContractArtifactPath(
  path: string,
): AsyncIterable<string> {
  const entries = await fs.readdir(path, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory() && entry.name !== "build-info") {
      yield* lookForContractArtifactPath(`${path}/${entry.name}`);
    } else if (entry.isFile() && entry.name.endsWith(".json")) {
      yield `${path}/${entry.name}`;
    }
  }
}
