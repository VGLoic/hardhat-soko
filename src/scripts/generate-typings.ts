import fs from "fs/promises";
import { toAsyncResult, LOG_COLORS, ScriptError } from "../utils";
import { LocalStorageProvider } from "../local-storage-provider";

/**
 * Based from the Soko releases folder content, generate a `summary-exports.ts`, a `summary.json` and a `index.ts` files in the Soko typings folder.
 * This file contains the PROJECTS object that maps the project name to the contracts and tags.
 * ```ts
 * export const SOKO_PATH = "<the configured Soko path>"
 * export const PROJECTS = {
 *    "my-project": {
 *      contracts: {
 *        "src/Counter.sol/Counter": ["latest", "v1.3.1"],
 *        "src/IncrementOracle.sol/IncrementOracle": ["latest", "v1.3.1"],
 *      },
 *      tags: {
 *        latest: [
 *          "src/Counter.sol/Counter",
 *          "src/IncrementOracle.sol/IncrementOracle",
 *        ],
 *        "v1.3.1": [
 *          "src/Counter.sol/Counter",
 *          "src/IncrementOracle.sol/IncrementOracle",
 *        ],
 *      }
 *    }
 * } as const;
 * ```
 */
export async function generateArtifactsSummariesAndTypings(
  sokoTypingsPath: string,
  _filterSimilarContracts: boolean,
  opts: { debug?: boolean } = {},
  localProvider: LocalStorageProvider,
) {
  // Check if the typings folder exists
  const doesTypingsFolderExist = await fs
    .stat(sokoTypingsPath)
    .catch(() => false);
  if (!doesTypingsFolderExist) {
    console.log(
      LOG_COLORS.log,
      "\nThe directory containing the Soko typings has not been found, initializing it.",
    );
    const typingsDirCreationResult = await toAsyncResult(
      fs.mkdir(sokoTypingsPath, { recursive: true }),
      { debug: opts.debug },
    );
    if (!typingsDirCreationResult.success) {
      throw new ScriptError(
        `Error creating the local Soko typings directory ${sokoTypingsPath}`,
      );
    }
  }

  const projectsResult = await toAsyncResult(
    localProvider.listProjects(),
    opts,
  );
  if (!projectsResult.success) {
    throw new ScriptError("Error listing the projects");
  }
  const projects = projectsResult.value;
  if (projects.length === 0) {
    console.error(
      LOG_COLORS.warn,
      "\nNo projects have been found. Generating an empty summary.",
    );

    const emptySummariesResult = await toAsyncResult(
      writeEmptySummaries(localProvider.rootPath, sokoTypingsPath, opts),
      opts,
    );

    if (!emptySummariesResult.success) {
      throw new ScriptError(
        "Error creating default typings when no projects have been found",
      );
    }

    return;
  }

  // project -> contract -> tag
  const summary: Record<
    string,
    {
      tagsPerContract: Record<string, string[]>;
      contractsPerTag: Record<string, string[]>;
    }
  > = {};

  for (const project of projects) {
    const tagsResult = await toAsyncResult(
      localProvider.listTags(project),
      opts,
    );
    if (!tagsResult.success) {
      throw new ScriptError(`Error listing the tags for project "${project}"`);
    }
    const tagsPerContract: Record<string, string[]> = {};
    const contractsPerTag: Record<string, string[]> = {};
    for (const { tag } of tagsResult.value) {
      if (!contractsPerTag[tag]) {
        contractsPerTag[tag] = [];
      }
      const artifactResult = await toAsyncResult(
        localProvider.retrieveArtifactByTag(project, tag),
        { debug: opts.debug },
      );
      if (!artifactResult.success) {
        throw new ScriptError(
          `Error retrieving the artifact for project "${project}" and tag "${tag}"`,
        );
      }
      for (const contractPath in artifactResult.value.output.contracts) {
        const contracts = artifactResult.value.output.contracts[contractPath];
        for (const contractName in contracts) {
          const contractKey = `${contractPath}:${contractName}`;
          contractsPerTag[tag].push(contractKey);
          if (!tagsPerContract[contractKey]) {
            tagsPerContract[contractKey] = [];
          }
          tagsPerContract[contractKey].push(tag);
        }
      }
    }
    summary[project] = { tagsPerContract, contractsPerTag };
  }

  // Generate the `generate/summary-exports.ts` content
  let generatedSummary = `// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.\n\n`;
  generatedSummary += `export const SOKO_PATH="${localProvider.rootPath}";\n\n`;
  generatedSummary += `export const PROJECTS = {\n`;
  for (const project in summary) {
    generatedSummary += `  "${project}": {\n`;
    generatedSummary += `    contracts: {\n`;
    for (const contract in summary[project].tagsPerContract) {
      generatedSummary += `      "${contract}": ${JSON.stringify(
        summary[project].tagsPerContract[contract],
      )},\n`;
    }
    generatedSummary += `    },\n`;
    generatedSummary += `    tags: {\n`;
    for (const tag in summary[project].contractsPerTag) {
      generatedSummary += `      "${tag}": ${JSON.stringify(
        summary[project].contractsPerTag[tag],
      )},\n`;
    }
    generatedSummary += `    },\n`;
    generatedSummary += `  },\n`;
  }
  generatedSummary += `} as const;\n`;

  // Write the `summary-exports.ts` file
  const writeTsResult = await toAsyncResult(
    fs.writeFile(`${sokoTypingsPath}/summary-exports.ts`, generatedSummary),
    { debug: opts.debug },
  );
  if (!writeTsResult.success) {
    throw new ScriptError(
      `Error writing the summary-exports.ts file: ${writeTsResult.error}`,
    );
  }
  // Write the `summary.json` file
  const writeJsonResult = await toAsyncResult(
    fs.writeFile(
      `${sokoTypingsPath}/summary.json`,
      JSON.stringify(
        {
          sokoPath: localProvider.rootPath,
          projects: summary,
        },
        null,
        4,
      ),
    ),
    { debug: opts.debug },
  );
  if (!writeJsonResult.success) {
    throw new ScriptError(
      `Error writing the summary.json file: ${writeJsonResult.error}`,
    );
  }
  const writeTypingsResult = await toAsyncResult(
    fs.writeFile(
      `${sokoTypingsPath}/index.ts`,
      await fs.readFile(`${__dirname}/typings.txt`, "utf-8"),
    ),
    { debug: opts.debug },
  );
  if (!writeTypingsResult.success) {
    throw new Error(
      `Error writing the index.ts file: ${writeTypingsResult.error}`,
    );
  }
}

function generateEmptyReleasesSummaryTsContent(sokoDirectory: string) {
  return `// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.
  export const SOKO_PATH="${sokoDirectory}";
  
  export const PROJECTS = {} as const;
  `;
}
function generateEmptyReleasesSummaryJsonContent(sokoPath: string) {
  return {
    sokoPath,
    projects: {},
  };
}

async function writeEmptySummaries(
  sokoDirectory: string,
  sokoTypingsPath: string,
  opts: { debug?: boolean } = {},
) {
  const writeEmptyTsSummaryResult = await toAsyncResult(
    fs.writeFile(
      `${sokoTypingsPath}/summary-exports.ts`,
      generateEmptyReleasesSummaryTsContent(sokoDirectory),
    ),
    { debug: opts.debug },
  );
  if (!writeEmptyTsSummaryResult.success) {
    throw new Error(
      `Error writing the summary-exports.ts file: ${writeEmptyTsSummaryResult.error}`,
    );
  }
  const writeEmptyJsonResult = await toAsyncResult(
    fs.writeFile(
      `${sokoTypingsPath}/summary.json`,
      JSON.stringify(
        generateEmptyReleasesSummaryJsonContent(sokoDirectory),
        null,
        4,
      ),
    ),
    { debug: opts.debug },
  );
  if (!writeEmptyJsonResult.success) {
    throw new Error(
      `Error writing the summary.json file: ${writeEmptyJsonResult.error}`,
    );
  }
  const writeTypingsResult = await toAsyncResult(
    fs.writeFile(
      `${sokoTypingsPath}/index.ts`,
      await fs.readFile(`${__dirname}/typings.txt`, "utf-8"),
    ),
    { debug: opts.debug },
  );
  if (!writeTypingsResult.success) {
    throw new Error(
      `Error writing the index.ts file: ${writeTypingsResult.error}`,
    );
  }
}
