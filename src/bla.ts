// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.
import fs from "fs/promises";

const SOKO_PATH = ".soko";

const PROJECTS = {
  stuff: {
    contracts: {
      "src/Counter.sol:Counter": ["latest", "v1.1.1"],
      "src/IncrementOracle.sol:IncrementOracle": ["latest", "v1.1.1"],
    },
    tags: {
      latest: [
        "src/Counter.sol:Counter",
        "src/IncrementOracle.sol:IncrementOracle",
      ],
      "v1.1.1": [
        "src/Counter.sol:Counter",
        "src/IncrementOracle.sol:IncrementOracle",
      ],
    },
  },
} as const;

// export type Project = keyof typeof PROJECTS extends never
//   ? string
//   : keyof typeof PROJECTS;
export type Project = keyof typeof PROJECTS;

export type Contract<TProject> = TProject extends Project
  ? keyof (typeof PROJECTS)[TProject]["contracts"]
  : string;
export type Tag<TProject> = TProject extends Project
  ? keyof (typeof PROJECTS)[TProject]["tags"]
  : string;

type AvailableTagForContractAsArray<TProject, TContract> =
  TProject extends Project
    ? TContract extends Contract<TProject>
      ? (typeof PROJECTS)[TProject]["contracts"][TContract]
      : string[]
    : string[];

export type AvailableTagForContract<TProject, TContract> =
  AvailableTagForContractAsArray<TProject, TContract>[number];

type AvailableContractsForTagAsArray<TProject, TTag> = TProject extends Project
  ? TTag extends Tag<TProject>
    ? (typeof PROJECTS)[TProject]["tags"][TTag]
    : string[]
  : string[];
export type AvailableContractForTag<TProject, TTag> =
  AvailableContractsForTagAsArray<TProject, TTag>[number];

type FallbackString = string & {};

export function project<TProject extends Project | FallbackString>(
  project: TProject,
) {
  return {
    /**
     * Utility functions for a given contract
     * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
     * @returns Utility functions for the given contract
     * @example ```typescript
     * const counterUtils = project("my-project").contract("src/Counter.sol:Counter");
     * const availableTags = counterUtils.getAvailableTags();
     * const counterArtifact = await counterUtils.getArtifact("v1.3.1");
     * ```
     */
    contract<TContract extends Contract<TProject>>(contractKey: TContract) {
      return {
        getArtifact(tag: AvailableTagForContract<TProject, TContract>) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getAvailableTags(): AvailableTagForContractAsArray<
          TProject,
          TContract
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].contracts[contractKey as string];
        },
      };
    },
    /**
     * Utility functions for a given tag
     * @param tag Tag
     * @returns Utility functions for the given tag
     * @example ```typescript
     * const v1_3_1Utils = project("my-project").tag("v1.3.1");
     * const availableContracts = v1_3_1Utils.getAvailableContracts();
     * const incrementOracleArtifact = await v1_3_1Utils.getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
     * ```
     */
    tag<TTag extends Tag<TProject>>(tag: TTag) {
      return {
        getContractArtifact(
          contractKey: AvailableContractForTag<TProject, TTag>,
        ) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getAvailableContracts(): AvailableContractsForTagAsArray<
          TProject,
          TTag
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].tags[tag];
        },
      };
    },
  };
}

type X = AvailableContractForTag<"stuff", "latest">;
const abc = project("stuff")
  .contract("src/IncrementOracle.sol:IncrementOracle")
  .getArtifact("v1.1.1");

// /**
//  * Utility functions for a given contract
//  * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
//  * @returns Utility functions for the given contract
//  * @example ```typescript
//  * const counterUtils = contract("src/Counter.sol:Counter");
//  * const availableReleases = counterUtils.getAvailableReleases();
//  * const counterArtifact = await counterUtils.getArtifact("v1.3.1");
//  * ```
//  */
// export function contract<TContract extends Contract | FallbackString>(
//   contractKey: TContract,
// ) {
//   return {
//     /**
//      * Retrieve the contract artifact for a given release
//      * @param release Release name
//      * @returns The contract artifact
//      * @example ```typescript
//      * const counterArtifact = await contract("src/Counter.sol:Counter").getArtifact("v1.3.1");
//      * ```
//      */
//     getArtifact(
//       release: Contract extends never
//         ? string
//         : TContract extends Contract
//           ? AvailableReleaseForContract<TContract>
//           : never,
//     ) {
//       return getArtifact(contractKey, release);
//     },
//     /**
//      * Get the available releases for the contract
//      * @returns The available releases for the contract
//      */
//     getAvailableReleases: (): TContract extends Contract
//       ? (typeof CONTRACTS)[TContract]
//       : string[] => {
//       if (contractKey in CONTRACTS) {
//         return CONTRACTS[
//           contractKey as Contract
//           // eslint-disable-next-line @typescript-eslint/no-explicit-any
//         ] as any;
//       }
//       throw new Error(`Contract not found for contract key: ${contractKey}`);
//     },
//   };
// }

// /**
//  * Utility functions for a given release
//  * @param release Release name
//  * @returns Utility functions for the given release
//  * @example ```typescript
//  * const v1_3_1Utils = release("v1.3.1");
//  * const availableContracts = v1_3_1Utils.getAvailableContracts();
//  * const incrementOracleArtifact = await v1_3_1Utils.getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
//  * ```
//  */
// export function release<TRelease extends Release | FallbackString>(
//   release: TRelease,
// ) {
//   return {
//     /**
//      * Retrieve the contract artifact for a given contract
//      * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
//      * @returns The contract artifact
//      * @example ```typescript
//      * const incrementOracleArtifact = await release("v1.3.1").getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
//      * ```
//      */
//     getContractArtifact(
//       contractKey: TRelease extends Release
//         ? AvailableContractForRelease<TRelease>
//         : string,
//     ) {
//       return getArtifact(contractKey, release);
//     },
//     /**
//      * Get the available contracts for the release
//      * @returns The available contracts for the release
//      */
//     getAvailableContracts: (): TRelease extends Release
//       ? (typeof RELEASES)[TRelease]
//       : string[] => {
//       if (release in RELEASES) {
//         return RELEASES[
//           release as Release
//           // eslint-disable-next-line @typescript-eslint/no-explicit-any
//         ] as any;
//       }
//       throw new Error(`Release not found for release: ${release}`);
//     },
//   };
// }

async function getArtifact(
  project: string,
  tag: string,
  contractKey: string,
): Promise<unknown> {
  const buildInfoResult = await toAsyncResult(
    getReleaseBuildInfo(project, tag),
  );
  if (!buildInfoResult.success) {
    throw buildInfoResult.error;
  }

  const contractPieces = contractKey.split(":");
  const contractName = contractPieces.at(-1);
  if (!contractName) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const contractPath = contractPieces.at(0);
  if (!contractPath) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const contractArtifact = (buildInfoResult.value as any).output.contracts[
    contractPath
  ][contractName];
  if (!contractArtifact) {
    throw new Error(
      `Contract artifact not found for contract key: ${contractKey} with artifact ${project}:${tag}`,
    );
  }
  return contractArtifact;
}

/**
 * Get the artifact of a release
 * @param release Name of the release
 * @returns The build info content of the release
 * @example ```typescript
 * const releaseBuildInfo = await getReleaseBuildInfo("v1.3.1");
 * ```
 */
export async function getReleaseBuildInfo(
  project: string,
  tag: string,
): Promise<unknown> {
  const buildInfoExists = await fs
    .stat(`${SOKO_PATH}/${project}/tags/${tag}.json`)
    .catch(() => false);
  if (!buildInfoExists) {
    throw new Error(`artifact not found for "${project}:${tag}". Skipping`);
  }
  const buildInfoContentResult = await toAsyncResult(
    fs
      .readFile(`${SOKO_PATH}/${project}/tags/${tag}.json`, "utf-8")
      .then(JSON.parse),
  );
  if (!buildInfoContentResult.success) {
    console.error(buildInfoContentResult.error);
    throw buildInfoContentResult.error;
  }

  return buildInfoContentResult.value;
}

function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}
