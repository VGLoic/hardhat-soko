import "hardhat/types/config";
import { extendConfig } from "hardhat/config";
import { HardhatConfig, HardhatUserConfig } from "hardhat/types/config";
import { z } from "zod";
import fs from "fs/promises";

export async function addFile() {
  await fs.mkdir("./.soko", { recursive: true });
  const key = `./.soko/local-file-test-${Date.now()}.txt`;
  await fs.writeFile(key, "Hello World!");
}

export async function listFiles() {
  const files = await fs.readdir("./.soko");
  console.log(files);
}

export async function clearFiles() {
  await fs.rm(".soko", { recursive: true });
}

declare module "hardhat/types/config" {
  export interface HardhatUserConfig {
    soko?: {
      debug?: boolean;
      storageConfiguration: {
        type: "aws";
        awsRegion: string;
        awsBucketName: string;
        awsAccessKeyId: string;
        awsSecretAccessKey: string;
      };
    };
  }

  export interface HardhatConfig {
    soko?: {
      debug: boolean;
      storageConfiguration: {
        type: "aws";
        awsRegion: string;
        awsBucketName: string;
        awsAccessKeyId: string;
        awsSecretAccessKey: string;
      };
    };
  }
}

const SOKO_DIRECTORY = ".soko";

extendConfig(
  async (config: HardhatConfig, userConfig: Readonly<HardhatUserConfig>) => {
    if (userConfig.soko === undefined) {
      config.soko = undefined;
      return;
    }

    const sokoParsingResult = z
      .object({
        debug: z.boolean().default(false),
        storageConfiguration: z.object({
          type: z.literal("aws"),
          awsRegion: z.string().min(1),
          awsBucketName: z.string().min(1),
          awsAccessKeyId: z.string().min(1),
          awsSecretAccessKey: z.string().min(1),
        }),
      })
      .safeParse(userConfig.soko);

    if (!sokoParsingResult.success) {
      console.warn(
        `Configuration for Soko has been found but seems invalid. Please consult the below errors: \n${sokoParsingResult.error.errors.map(
          (error) => {
            return `  - ${error.path.join(".")}: ${error.message} (${error.code})`;
          },
        )}`,
      );
      return;
    }

    const sokoDirectoryStat = await fs.stat(SOKO_DIRECTORY).catch(() => null);
    if (sokoDirectoryStat === null) {
      await initiateGeneratedFolder(SOKO_DIRECTORY, { debug: false });
    } else {
      if (!sokoDirectoryStat.isDirectory()) {
        console.warn(
          `A file named "${SOKO_DIRECTORY}" exists in the root directory. Please remove it before continuing with Soko.`,
        );
        return;
      }

      // Check if there are the generated typings and summary files
      const generatedTypingStats = await fs
        .stat(`${SOKO_DIRECTORY}/generated/typings.ts`)
        .catch(() => null);
      const generatedTsSummaryStats = await fs
        .stat(`${SOKO_DIRECTORY}/generated/summary.ts`)
        .catch(() => null);
      const generatedJsonSummaryStats = await fs
        .stat(`${SOKO_DIRECTORY}/generated/summary.json`)
        .catch(() => null);

      if (
        !generatedTypingStats ||
        !generatedTsSummaryStats ||
        !generatedJsonSummaryStats
      ) {
        console.warn(
          `The Soko directory exists but some of the generated files are missing. They will be regenerated using default values.`,
        );
        await initiateGeneratedFolder(SOKO_DIRECTORY, { debug: false });
      }
    }

    config.soko = sokoParsingResult.data;
  },
);

async function initiateGeneratedFolder(
  sokoDirectory: string,
  opts: { debug: boolean },
) {
  // Remove the generated folder if it exists
  await fs
    .rm(`${sokoDirectory}/generated`, { recursive: true })
    .catch(() => {});

  // Create the generated folder
  const creationDirResult = await toAsyncResult(
    fs.mkdir(`${sokoDirectory}/generated`),
    opts,
  );
  if (!creationDirResult.success) {
    console.warn(
      completeMessage(
        "Unable to create the generated folder in the Soko directory.",
        opts,
      ),
    );
    return;
  }

  const SUMMARY_TS_CONTENT = `// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.

export const CONTRACTS = {} as const;

export const RELEASES = {} as const;`;

  const TYPINGS_TS_CONTENT = `// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.

import { CONTRACTS, RELEASES } from "./summary";

export type Contract = keyof typeof CONTRACTS;
export type Release = keyof typeof RELEASES;

export type AvailableReleaseForContract<TContract extends Contract> =
  (typeof CONTRACTS)[TContract][number];

export type AvailableContractForRelease<TRelease extends Release> =
  (typeof RELEASES)[TRelease][number];`;

  const tsSummaryResult = await toAsyncResult(
    fs.writeFile(`${sokoDirectory}/generated/summary.ts`, SUMMARY_TS_CONTENT),
    opts,
  );
  if (!tsSummaryResult.success) {
    console.warn(
      completeMessage(
        "Unable to create the summary.ts file in the generated folder.",
        opts,
      ),
    );
    return;
  }
  const typingResult = await toAsyncResult(
    fs.writeFile(`${sokoDirectory}/generated/typings.ts`, TYPINGS_TS_CONTENT),
    opts,
  );
  if (!typingResult.success) {
    console.warn(
      completeMessage(
        "Unable to create the typings.ts file in the generated folder.",
        opts,
      ),
    );
    return;
  }
  const jsonSummaryResult = await toAsyncResult(
    fs.writeFile(
      `${sokoDirectory}/generated/summary.json`,
      JSON.stringify({ contracts: {}, releases: {} }),
    ),
    opts,
  );
  if (!jsonSummaryResult.success) {
    console.warn(
      completeMessage(
        "Unable to create the summary.json file in the generated folder.",
        opts,
      ),
    );
    return;
  }
}

export function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}

function completeMessage(message: string, opts: { debug: boolean }) {
  return `Soko: ${message}${opts.debug ? "" : "\nFor more information, please run the same command with the `debug: true` option in Soko part of Hardhat configuration."}`;
}
